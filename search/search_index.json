{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LinearML","text":"<p>A learning project where I try to build a ML library from scratch in C.</p>"},{"location":"#building-linearml","title":"Building LinearML","text":"<p>LinearML uses BuildMe as it's build system. It's a build system that I made. It is still WIP.</p> <p>Install the BuildMe with the command</p> <pre><code>pip3 install buildme\n</code></pre> <p>Clone the repo</p> <pre><code>git clone --depth=1 -b master https://github.com/Adwaith-Rajesh/LinearML.git\n</code></pre> <p>Compile the <code>liblinearml.so</code></p> <pre><code>cd ./LinearML\nchmod +x buildme\n</code></pre> <pre><code>./buildme all\n</code></pre> <p>This will create a <code>build</code> folder where the shared object will be present in the <code>build/lib</code> folder</p>"},{"location":"#testing-the-install","title":"Testing the install","text":"<p>Let's create a simple Array and print it to check whether everything works</p> <pre><code>touch test_lm.c\n</code></pre> <pre><code>// test_lm.c\n\n#define INCLUDE_ARRAY_STATS\n#include \"ds/array.h\"\n\nint main(void) {\nArray *arr = arr_create(3);\n\nARR_AT(arr, 0) = 1;\nARR_AT(arr, 1) = 4;\nARR_AT(arr, 2) = 5;\n\narr_print(arr);\narr_free(arr);\n\nreturn 0;\n}\n</code></pre> <p>Compile</p> <pre><code>gcc -o test_lm test_lm.c -I./include -L./build/lib -llinearml -lm\n</code></pre> <p>Run</p> <pre><code>$ LD_LIBRARY_PATH=./build/lib ./test_lm\n[ 1.00 4.00 5.00 ]\n</code></pre>"},{"location":"ds/array/","title":"Array","text":""},{"location":"ds/array/#structure","title":"Structure","text":"<pre><code>typedef struct {\nsize_t size;\nfloat *arr;\n} Array;\n</code></pre> <p>Array is LinearML way of storing both the C array and the number of elements at the same time.</p>"},{"location":"ds/array/#examples","title":"Examples","text":""},{"location":"ds/array/#1-creating-a-simple-array","title":"1. Creating a simple Array","text":"<pre><code>#include \"ds/array.h\"\n\nint main(void) {\n// create an array with 3 values\nArray *arr = arr_create(3);\n\nARR_AT(arr, 0) = 1;  // set arr[0] = 1\nARR_AT(arr, 1) = 4;  // set arr[1] = 4\nARR_AT(arr, 2) = 5;  // set arr[2] = 5\n\narr_print(arr);\n\n// free Array crated using arr_crate\narr_free(arr);\n\nreturn 0;\n}\n</code></pre> <pre><code>[ 1.00 4.00 5.00 ]\n</code></pre>"},{"location":"ds/array/#2-create-an-array-using-existing-c-array","title":"2. Create an Array using existing C array","text":"<pre><code>#include \"ds/array.h\"\n\nint main(void) {\nfloat arr_vals[] = {1, 2, 3, 4};\n\n// use an existing C array with 4 values\nArray *arr = arr_init(arr_vals, 4);\n\nARR_AT(arr, 0) = 5;  // set arr[0] = 5\narr_print(arr);\n\n// free Array crated using arr_init\narr_init_free(arr);\nreturn 0;\n}\n</code></pre> <pre><code>[ 5.00 2.00 3.00 4.00 ]\n</code></pre>"},{"location":"ds/array/#3-changing-the-float-precision-during-printing","title":"3. Changing the float precision during printing","text":"<pre><code>#include \"ds/array.h\"\n\nint main(void) {\n// create an array with 3 values\nArray *arr = arr_create(3);\n\nARR_AT(arr, 0) = 1;  // set arr[0] = 1\nARR_AT(arr, 1) = 4;  // set arr[1] = 4\nARR_AT(arr, 2) = 5;  // set arr[2] = 5\n\n// use arr_printp instead of arr_print\narr_printp(arr, 0);\n\n// free Array crated using arr_crate\narr_free(arr);\n\nreturn 0;\n}\n</code></pre> <pre><code>[ 1 4 5 ]\n</code></pre>"},{"location":"ds/array/#4-map-a-function-over-the-array","title":"4. Map a function over the Array","text":"<pre><code>#include \"ds/array.h\"\n\nfloat add_three(float val) {\nreturn val + 3;\n}\n\nint main(void) {\n// create an array with 3 values\nArray *arr = arr_create(3);\n\nARR_AT(arr, 0) = 1;  // set arr[0] = 1\nARR_AT(arr, 1) = 4;  // set arr[1] = 4\nARR_AT(arr, 2) = 5;  // set arr[2] = 5\n\n// the function will return the same array back for\n// convenience reasons\narr_print(arr_map(arr, add_three));\n\n// free Array crated using arr_crate\narr_free(arr);\n\nreturn 0;\n}\n</code></pre> <pre><code>[ 4.00 7.00 8.00 ]\n</code></pre>"},{"location":"ds/array/#5-array-stats","title":"5. Array stats","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define INCLUDE_ARRAY_STATS\n#include \"ds/array.h\"\n\n\nint main(void) {\n// create an array with 3 values\nArray *arr = arr_create(3);\n\nARR_AT(arr, 0) = 1;  // set arr[0] = 1\nARR_AT(arr, 1) = 4;  // set arr[1] = 4\nARR_AT(arr, 2) = 5;  // set arr[2] = 5\n\narr_print(arr);\n\nprintf(\"Mean: %.2f\\n\", arr_mean(arr));\nprintf(\"Max: %.2f\\n\", arr_max(arr));\nprintf(\"Min: %.2f\\n\", arr_min(arr));\n\n// free Array crated using arr_crate\narr_free(arr);\n\nreturn 0;\n}\n</code></pre> <pre><code>[ 1.00 4.00 5.00 ]\nMean: 3.33\nMax: 5.00\nMin: 1.00\n</code></pre>"},{"location":"ds/mat/","title":"Mat","text":""},{"location":"ds/mat/#structure","title":"Structure","text":"<pre><code>typedef struct {\nfloat *elems;\nsize_t rows;\nsize_t cols;\n} Mat;\n</code></pre> <p>Internally the Matrix is 1D array where the values are stored in row major order.</p> <pre><code>/*\nCreate a rows x cols matrix\n*/\nMat *mat_create(size_t rows, size_t cols);\n\n/*\nCreate a Mat from an existing array\n*/\nMat *mat_create_from_array(float *arr, size_t rows, size_t cols);\n\n/*\nCreate a zero matrix of size rows x cols\n*/\nMat *mat_create_zeros(size_t rows, size_t cols);\n\n/*\nCreate a size x size identity matrix\n*/\nMat *mat_identity(size_t size);\n\n/*\nDisplay the given matrix\n*/\nvoid mat_printp(Mat *mat, int print_prec);\n\n/*\nFree a Mat\n*/\nvoid mat_free(Mat *mat);\n\n/*\nFree mat with user created arr\n*/\nvoid mat_free_no_array(Mat *mat);\n\n/*\nAdd two Mat of the same dimension\n\nAdds mat2 to mat1 and returns mat1\n*/\nMat *mat_add(Mat *mat1, Mat *mat2);\n\n/*\nSubtract two Mat of the same dimension\n\nSubtract mat2 from mat1 and returns mat1\n*/\nMat *mat_sub(Mat *mat1, Mat *mat2);\n\n/*\nMultiplies mat1 and mat2 and returns a new Mat\n\nyou need to free the new Mat\n*/\nMat *mat_mul(Mat *mat1, Mat *mat2);\n\n/*\nMultiplies a scalar value to the Mat and returns the given mat\n*/\nMat *mat_scalar_mul(Mat *mat, float val);\n\n/*\nReturns a new matrix that is the transpose of the given mat\n\nyou need to free the new matrix\n*/\nMat *mat_transpose(Mat *mat);\n\n/*\nFind the determinant of a matrix\n*/\nfloat mat_det(Mat *mat);\n\n/*\nFind the cofactor of a given elements in Mat\n*/\nfloat mat_cofactor(Mat *mat, size_t row, size_t col);\n\n/*\nReturns a new Mat, that is the cofactor matrix of the given Mat\n\nYou need to free the returned Mat\n*/\nMat *mat_cofactor_matrix(Mat *mat);\n\n/*\nReturns a new Mat that is the adjoint of the given Mat\n\nYou need to free the returned Mat;\n*/\nMat *mat_adj(Mat *mat);\n\n/*\nReturn a new Mat that is the inverse of the given Mat\n\nYou need to free the returned Mat\n*/\nMat *mat_inverse(Mat *mat);\n</code></pre> <p>Here is a simple example on finding the inverse of a matrix</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include \"ds/mat.h\"\n\nint main(void) {\nMat *mat = mat_create(2, 2);\n\nMAT_AT(mat, 0, 0) = 4;\nMAT_AT(mat, 0, 1) = 7;\n\nMAT_AT(mat, 1, 0) = 2;\nMAT_AT(mat, 1, 1) = 6;\n\nmat_printp(mat, 5);\nprintf(\"\\n\");\n\nMat *adj = mat_adj(mat);\nmat_print(adj);\n\nprintf(\"\\n\");\n\nMat *inv = mat_inverse(mat);\nmat_printp(inv, 7);\n\nmat_free(mat);\nmat_free(adj);\nmat_free(inv);\n\nreturn 0;\n}\n</code></pre> <pre><code>  4.00000   7.00000\n  2.00000   6.00000\n\n  6.00   -7.00\n  -2.00   4.00\n\n  0.6000000   -0.7000000\n  -0.2000000   0.4000000\n</code></pre> <p>If you have any queries feel free to contact me through any of the socials given below</p>"},{"location":"ds/mat/#1-available-functions","title":"1. Available functions.","text":""},{"location":"ds/mat/#2-examples","title":"2. Examples.","text":""},{"location":"ds/vec/","title":"vec","text":""},{"location":"ds/vec/#this-is-the-vec-file","title":"this is the vec file","text":""},{"location":"ml/linregress/","title":"Linear Regression","text":"<p>\\(\\text{Hello World}\\)</p>"},{"location":"ml/multiregress/","title":"Multiple Linear Regression","text":""},{"location":"ml/multiregress/#the-math","title":"The Math","text":"<p>Definition can be found here.</p> <p>In simple terms MLR can described as</p> <p>\"The case of one explanatory variable is called simple linear regression; for more than one, the process is called multiple linear regression.\"</p> <p>The formula / model for MLR is</p> \\[ y = \\beta_0 + \\beta_1x_1 + \\dots + \\beta_nx_n + \\epsilon \\] <ul> <li>\\(y\\), is the predicted values</li> <li>\\(\\beta_0\\), is the y-intercept</li> <li>\\(\\beta_1x_1\\), is the first regression coefficient (\\(\\beta_1\\)) of the first independent variable (\\(X_1\\))</li> <li>\\(\\dots\\), do the same for all independent variables.</li> <li>\\(\\beta_nx_n\\), is the regression coefficient of the last independent variable</li> <li>\\(\\epsilon\\), is the model error.</li> </ul> <p>The same formula in Matrix form can be represented as</p> \\[ Y = \\beta X + \\epsilon \\] \\[ \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{bmatrix} = \\begin{bmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1k} \\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2k} \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ x_{N1} &amp; x_{N2} &amp; \\cdots &amp; x_{Nk} \\\\ \\end{bmatrix} * \\begin{bmatrix} \\beta_0 \\\\ \\beta_1 \\\\ \\vdots \\\\ \\beta_k \\end{bmatrix} + \\begin{bmatrix} \\epsilon_1 \\\\ \\epsilon_2 \\\\ \\vdots \\\\ \\epsilon_N \\\\ \\end{bmatrix} \\] <p>Our goal is to find \\(\\beta\\) (coefficients / parameters) and to minimize \\(\\epsilon^2\\). The methods used to do so is called the Least Squared Method.</p> <p>Now, the least squared estimator for the given model is</p> \\[ \\beta = {(X^TX)}^{-1}(X^TY) \\] <p>The proof for this derivation can be found here.</p>"},{"location":"ml/multiregress/#the-code","title":"The Code","text":"<p>Here is an example of training the Multiple Linear Regression Model with an example data.</p> <p>Data</p> \\[ \\begin{array}{|c|c|c|} \\hline     \\text{${x_1}$} &amp; \\text{${x_2}$} &amp; \\text{${y}$} \\\\ \\hline     1 &amp; 1 &amp; 3.25 \\\\ \\hline     1 &amp; 2 &amp; 6.5 \\\\ \\hline     2 &amp; 2 &amp; 3.5 \\\\ \\hline     0 &amp; 1 &amp; 5.0 \\\\ \\hline \\end{array} \\] <p>When fitting the <code>MLinearRegressionModel</code> using the function <code>mlinregress_fit</code>, the \\(X\\) matrix must be</p> \\[ X = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 2 \\\\ 2 &amp; 2 \\\\ 0 &amp; 1 \\\\ \\end{bmatrix} \\] <p>The \\(1^{st}\\) column are the values of \\(x_1\\) and \\(2^{nd}\\) columns are the values of \\(x_2\\).</p> <p>The \\(Y\\) matrix will look like the following</p> \\[ Y = \\begin{bmatrix} 3.25 \\\\ 6.5 \\\\ 3.5 \\\\ 5.0 \\\\ \\end{bmatrix} \\] <p>In code</p> <pre><code>#include &lt;stdio.h&gt;\n\n#include \"ds/array.h\"\n#include \"ml/multiregress.h\"\n\nint main(void) {\nfloat x_vals[] = {\n1, 1,\n1, 2,\n2, 2,\n0, 1};\n\nfloat y_vals[] = {\n3.25,\n6.5,\n3.5,\n5.0};\n\nMat *x_mat = mat_create_from_array(x_vals, 4, 2);\nMat *y_mat = mat_create_from_array(y_vals, 4, 1);\n\nMLinearRegressionModel *model = mlinregress_init();\nmlinregress_fit(model, x_mat, y_mat);\n\nprintf(\"coefficients:\\n\");\nmat_print(model-&gt;coefs);\nprintf(\"intercept: %f\\n\", model-&gt;intercept);\n\n// Array *arr = arr_create(2);\n// ARR_AT(arr, 0) = 4;\n// ARR_AT(arr, 1) = 3;\n\nprintf(\"predicted: %f\\n\", mlinregress_predict(model, (float[]){4, 3}, 2));\n// printf(\"predicted: %f\\n\", mlinregress_predict_arr(model, arr));\n\nmat_free_no_array(x_mat);\nmat_free_no_array(y_mat);\nmlinregress_free(model);\n}\n</code></pre> <p>Run the code, instructions here</p> <pre><code>coefficients:\n  -2.38\n  3.25\nintercept: 2.062500\npredicted: 2.312500\n</code></pre>"},{"location":"parsers/csv/","title":"CSV","text":"<p>LinearML has it's own simple CSV parser.</p> <p>Here is an example code on how to use it. Will be working on the code of Multiple Linear Regression mentioned here.</p> <p>Here, instead of the data being explicitly passed using Arrays, we will use CSV files.</p>"},{"location":"parsers/csv/#example","title":"Example","text":"<p><code>data.csv</code></p> 1 1 3.25 1 2 6.5 2 2 3.5 0 1 5.0 <pre><code>#include &lt;stdio.h&gt;\n\n#include \"ds/mat.h\"\n#include \"ml/multiregress.h\"\n#include \"parsers/csv.h\"\n\nint main(void) {\n// initialize the reader for 4 row 3 col CSV file,\n// using ',' as the delimiter\nCSV *csv_reader = csv_init(4, 3, ',');\n\n// parse the CSV file\ncsv_parse(csv_reader, \"data.csv\");\n\n// select the cols needed for X and Y values\nMat *X = csv_get_mat(csv_reader, (int[]){0, 1}, 2);\nMat *Y = csv_get_mat(csv_reader, (int[]){2}, 1);\n\n// initialize the model\nMLinearRegressionModel *model = mlinregress_init();\n\n// fit/train the model\nmlinregress_fit(model, X, Y);\n\n// print the properties.\nmat_printp(model-&gt;coefs, 7);\nprintf(\"Intercept: %f\\n\", model-&gt;intercept);\n\n// free everything.\nmlinregress_free(model);\nmat_free(X);\nmat_free(Y);\ncsv_free(csv_reader);\n}\n</code></pre>"},{"location":"parsers/csv/#limitations-of-the-parser","title":"Limitations of the parser","text":"<ul> <li>CSV file should not have a header</li> <li>all values must exists</li> <li>all values must be floats / ints</li> </ul>"}]}